To solve the 3Sum problem efficiently in Python, we can use a combination of sorting and the two-pointer technique. The idea is to first sort the array, then for each element in the array, use two pointers to find a pair of elements that sum up to the negative of the current element. This way, the sum of the three elements becomes zero.

Here's a step-by-step breakdown of the algorithm:

1. **Sort the array**: This helps in avoiding duplicate triplets and makes it easier to move the two pointers.

2. **Iterate through the array**: For each element, we'll treat it as the potential first element of a triplet.

3. **Two-pointer technique**: For the current element, use two pointers to find pairs that sum up to the negative of this element. The two pointers start from the elements immediately after the current element and the end of the array, moving towards each other.

4. **Avoiding duplicates**: Skip over duplicate elements to avoid duplicate triplets.

5. **Edge cases**: Handle cases like all zeros separately if needed.

Here's the Python code implementing this algorithm:

```python
def threeSum(nums):
    nums.sort()
    result = []

    for i in range(len(nums) - 2):
        # Avoid duplicates for the first element of the triplet
        if i > 0 and nums[i] == nums[i - 1]:
            continue

        left, right = i + 1, len(nums) - 1
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                result.append([nums[i], nums[left], nums[right]])
                # Skip duplicates for the second and third elements of the triplet
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                left += 1
                right -= 1

    return result
```

This code will work efficiently for the given problem statement, handling all the constraints and edge cases. It has a time complexity of O(n^2) in the worst case, which is optimal for this problem.